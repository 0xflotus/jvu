# JVU

Json-schema Validator Utilities

[npm](https://www.npmjs.com/package/jvu)

## Features

- Use any json-schema validator (which support basic protocol, TBD in schema)
- Expose native environment api

- jvu.add('...', schema) or env.addSchema
- jvu('...', object) or `validate/is`
- jvu('...') or `generate`
- jvu.find({ '...': value }), jvu.find(['...'])

- [Matching pattern](https://en.wikipedia.org/wiki/Pattern_matching)
- [Case Classes pattern](http://docs.scala-lang.org/tutorials/tour/case-classes.html)
- [if-less pattern](http://alisnic.github.io/posts/ifless/)

## Terms

- **validator** - a json-schema validator used for internal tasks
- **validation function** - a generated by path or schema function which checks any given argument, checks at among with a schema and returns `Boolean`

## List of supported json-schema validators

- **djv**
- **ajv**
- **jjv**

## Usage

Lets have an example - jsonSchema

```
jsonSchema = {
    "common": {
        "properties": {
            "type": {
                "enum": ["common"]
            }
        },
        "required": [
            "type"
        ]
    }
};
```

### initialize & add schema

Utils will create an env with a validator. An empty environment will be created without any namespaces.
```
jvu = require('jvu')(validator);
```

Validator environment is available with a `jvu.env` link. However, created `jvu` environment is actually inherited from validator environment, so you can use it if it does not intercept. This is done for the reason to decrease API changes needed to integrate `jvu` to existing code.

Use `add` to add json schema after initialization
```
jvu.add('...', jsonSchema);
```

### jvu('...') or generate

One of the `jvu` public methods is `generate` which literally generates a validation function from a registered json schema path. The validation function accept object as a param and returns `Boolean` flag, if an object matches to a given path.
For easily usage `generate` has a shorthand, which is `jvu` itself with first argument given as a path or schema. This doesn't conflict with `validate/is` method or its shorthand:
- one argument - partial execution,
- two arguments - returns a value.
Don't afraid to use `generate` function often - it caches all generated validation functions, so for one environment it will generate 1 function for 1 path.
```JavaScript
var testCommon = jvu('...#/common');
[commonObj].map(testCommon) // => [true]

var testNotCommon = jvu.generate('...#/common', true);
[commonObj].map(testNotCommon) // => [false]
```
`Generate` method is very helpful in `each`, `find` and other iterable functions.

### jvu('...', {}) or validate

Use `validate/is` to validate an object by schema reference
```
jvu('...#/common', { type: 'common' }) // => true
jvu.is('...#/common', { type: 'common' }) // => true
```

### jvu.find({})

Use `find` to easy `switch` condition.
```
var references = {
    '...#/common': 1
};

jvu.find(references, commonObj) // => 1
jvu.find(references, unknownObj) // => undefined
```

## API

- **add(String namespace, Object jsonSchema)** add schema to existing environment
- **generate(String reference[, Boolean isReverse])** generates function to use in functional expressions
- **is(String reference, Object data)** validate object by schema reference
- **find(Object/Array types, Object data)** iterates through an object or array to find appropriate schema to given object. Returns `undefined` if not found.
- **env** original environment

## TODO
- move env to prototype
- tests